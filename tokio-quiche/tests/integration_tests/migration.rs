// Copyright (C) 2025, Cloudflare, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

use h3i::quiche;
use std::net::SocketAddr;
use tokio_quiche::quic::SimpleConnectionIdGenerator;
use tokio_quiche::ConnectionIdGenerator as _;

use crate::fixtures::*;

#[tokio::test]
async fn test_passive_migration() {
    run_migration_test(false, 12345).await;
}

#[tokio::test]
async fn test_active_migration() {
    run_migration_test(true, 23456).await;
}

/// Tests that the client can migrate either actively or passively.
///
/// Active migration means the client intentionally chooses a new local address
/// to switch to. In this case, it must select a new DCID that was previously
/// issued to it by the server. The server then also switches to a new DCID
/// that was generated by the client.
///
/// Passive migration occurs when the client's address changes while keeping
/// the same source and destination CIDs. The client is not necessarily aware
/// of the change (e.g. due to NAT rebinding). Under these circumstances, the
/// endpoints are allowed to keep talking to each other with the existing
/// DCIDs.
///
/// The test simply binds a UDP socket on one address which is then used to
/// complete the handshake and send an initial HTTP/3 request. Next, it
/// switches (actively or passively) to a new socket bound to a different port
/// and sends an additional HTTP/3 request. If both requests complete that
/// means that the client was successfully migrated to the new address.
///
/// This requires using "plain" quiche as a client to properly control when and
/// where packets are sent to, which is not possible using h3i.
async fn run_migration_test(active: bool, base_port: u16) {
    let mut quic_settings = QuicSettings::default();
    quic_settings.active_connection_id_limit = 2;
    quic_settings.disable_active_migration = !active;
    quic_settings.disable_dcid_reuse = false;

    let (url, _) = start_server_with_settings(
        quic_settings,
        Http3Settings::default(),
        TestConnectionHook::new(),
        handle_connection,
    );
    let server_addr = extract_host_ipv4(&url);

    let mut client_config =
        quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();
    client_config.set_application_protos(&[b"h3"]).unwrap();
    client_config.set_initial_max_data(1500);
    client_config.set_initial_max_stream_data_bidi_local(1500);
    client_config.set_initial_max_stream_data_bidi_remote(1500);
    client_config.set_initial_max_stream_data_uni(1500);
    client_config.set_initial_max_streams_bidi(10);
    client_config.set_initial_max_streams_uni(3);
    client_config.set_active_connection_id_limit(2);
    // QUICv1 server can't initiate migration but disable it explicitly anyway.
    client_config.set_disable_active_migration(true);
    client_config.verify_peer(false);

    let client_scid = SimpleConnectionIdGenerator.new_connection_id();

    let client_addr = SocketAddr::new("127.0.0.1".parse().unwrap(), base_port);
    let socket = tokio::net::UdpSocket::bind(client_addr).await.unwrap();

    let mut conn = quiche::connect(
        Some("test.com"),
        &client_scid,
        client_addr,
        server_addr,
        &mut client_config,
    )
    .unwrap();

    if active {
        // Supply a second SCID to the server to facilitate active migration
        let extra_scid = SimpleConnectionIdGenerator.new_connection_id();
        conn.new_scid(&extra_scid, 0xAABBCCDDEEFF0123454678, false)
            .unwrap();
    }

    // Handshake.
    while !conn.is_established() {
        emit_flight(&socket, &mut conn).await;
        process_flight(&socket, client_addr, &mut conn).await;
    }

    // Create a new HTTP/3 connection once the QUIC connection is established.
    let h3_config = quiche::h3::Config::new().unwrap();
    let mut h3_conn =
        quiche::h3::Connection::with_transport(&mut conn, &h3_config).unwrap();

    // Client sends first request on the initial path.
    let req = vec![
        quiche::h3::Header::new(b":method", b"GET"),
        quiche::h3::Header::new(b":scheme", b"https"),
        quiche::h3::Header::new(b":authority", b"test.com"),
        quiche::h3::Header::new(b":path", b"/"),
        quiche::h3::Header::new(b"user-agent", b"quiche"),
    ];

    h3_conn.send_request(&mut conn, &req, true).unwrap();
    emit_flight(&socket, &mut conn).await;
    process_flight(&socket, client_addr, &mut conn).await;

    assert_eq!(process_h3_events(&mut h3_conn, &mut conn), (true, true));

    // Client migrates to new address.
    let migrated_addr = SocketAddr::new(client_addr.ip(), base_port + 1);
    let migrated_socket =
        tokio::net::UdpSocket::bind(migrated_addr).await.unwrap();

    let client_addr = if active {
        // We actively switch the connection to `migrated_addr` and report that
        // address for all packets we receive from now on.
        conn.migrate_source(migrated_addr)
            .expect("active migration should succeed");
        migrated_addr
    } else {
        // We keep using the original client address to simulate the fact that the
        // client doesn't know that the path changes (e.g. due to NAT rebinding).
        client_addr
    };

    // Client sends second request on the new address.
    h3_conn.send_request(&mut conn, &req, true).unwrap();
    emit_flight(&migrated_socket, &mut conn).await;

    let stats = conn.stats();
    assert_eq!(stats.path_challenge_rx_count, 0);

    process_flight(&migrated_socket, client_addr, &mut conn).await;

    let stats = conn.stats();
    assert_eq!(stats.path_challenge_rx_count, 1);

    // Client responds to PATH_CHALLENGE.
    emit_flight(&migrated_socket, &mut conn).await;

    // Client receives response for the second request.
    process_flight(&migrated_socket, client_addr, &mut conn).await;

    assert_eq!(process_h3_events(&mut h3_conn, &mut conn), (true, true));
}

async fn emit_flight(
    socket: &tokio::net::UdpSocket, conn: &mut quiche::Connection,
) {
    let flight = match quiche::test_utils::emit_flight(conn) {
        Ok(v) => v,

        Err(quiche::Error::Done) => return,

        Err(e) => panic!("failed to emit flight: {e:?}"),
    };

    for p in flight {
        // We avoid using the `from` field here on purpose, as in case of
        // passive migration the client might be unaware that their address
        // changed.
        socket.send_to(&p.0, p.1.to).await.unwrap();
    }
}

async fn process_flight(
    socket: &tokio::net::UdpSocket, client_addr: std::net::SocketAddr,
    conn: &mut quiche::Connection,
) {
    let mut buf = [0; 65535];

    socket.readable().await.unwrap();

    loop {
        let (len, from) = match socket.try_recv_from(&mut buf) {
            Ok(v) => v,
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => break,
            Err(e) => panic!("failed to receive packets: {e:?}"),
        };

        // We use an explicit `client_addr` here rather than the socket's
        // address to simulate cases where the client is not aware of its own
        // address changing during passive migration.
        let recv_info = quiche::RecvInfo {
            to: client_addr,
            from,
        };

        // Process potentially coalesced packets.
        let _ = conn.recv(&mut buf[..len], recv_info).unwrap();
    }
}

fn process_h3_events(
    h3_conn: &mut quiche::h3::Connection, conn: &mut quiche::Connection,
) -> (bool, bool) {
    let mut buf = [0; 65535];

    let mut got_headers = false;

    loop {
        match h3_conn.poll(conn) {
            Ok((_, quiche::h3::Event::Headers { .. })) => got_headers = true,

            Ok((stream_id, quiche::h3::Event::Data)) => {
                // Drain stream and drop the data.
                while h3_conn.recv_body(conn, stream_id, &mut buf).is_ok() {}
            },

            Ok((_, quiche::h3::Event::Finished)) => {
                // Request is complete, return.
                return (got_headers, true);
            },

            _ => {},
        }
    }
}
