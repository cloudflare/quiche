<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A QUIC connection."><title>Connection in quiche - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="quiche" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (6a979b3e3 2026-02-26)" data-channel="nightly" data-search-js="search-63369b7b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-41dd4d93.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5013f961.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Connection</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../quiche/index.html">quiche</a><span class="version">0.26.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Connection</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.active_scids" title="active_scids">active_scids</a></li><li><a href="#method.application_proto" title="application_proto">application_proto</a></li><li><a href="#method.available_dcids" title="available_dcids">available_dcids</a></li><li><a href="#method.close" title="close">close</a></li><li><a href="#method.destination_id" title="destination_id">destination_id</a></li><li><a href="#method.dgram_max_writable_len" title="dgram_max_writable_len">dgram_max_writable_len</a></li><li><a href="#method.dgram_purge_outgoing" title="dgram_purge_outgoing">dgram_purge_outgoing</a></li><li><a href="#method.dgram_recv" title="dgram_recv">dgram_recv</a></li><li><a href="#method.dgram_recv_front_len" title="dgram_recv_front_len">dgram_recv_front_len</a></li><li><a href="#method.dgram_recv_peek" title="dgram_recv_peek">dgram_recv_peek</a></li><li><a href="#method.dgram_recv_queue_byte_size" title="dgram_recv_queue_byte_size">dgram_recv_queue_byte_size</a></li><li><a href="#method.dgram_recv_queue_len" title="dgram_recv_queue_len">dgram_recv_queue_len</a></li><li><a href="#method.dgram_recv_vec" title="dgram_recv_vec">dgram_recv_vec</a></li><li><a href="#method.dgram_send" title="dgram_send">dgram_send</a></li><li><a href="#method.dgram_send_queue_byte_size" title="dgram_send_queue_byte_size">dgram_send_queue_byte_size</a></li><li><a href="#method.dgram_send_queue_len" title="dgram_send_queue_len">dgram_send_queue_len</a></li><li><a href="#method.dgram_send_vec" title="dgram_send_vec">dgram_send_vec</a></li><li><a href="#method.early_data_reason" title="early_data_reason">early_data_reason</a></li><li><a href="#method.gcongestion_enabled" title="gcongestion_enabled">gcongestion_enabled</a></li><li><a href="#method.get_next_release_time" title="get_next_release_time">get_next_release_time</a></li><li><a href="#method.is_closed" title="is_closed">is_closed</a></li><li><a href="#method.is_dgram_recv_queue_full" title="is_dgram_recv_queue_full">is_dgram_recv_queue_full</a></li><li><a href="#method.is_dgram_send_queue_full" title="is_dgram_send_queue_full">is_dgram_send_queue_full</a></li><li><a href="#method.is_draining" title="is_draining">is_draining</a></li><li><a href="#method.is_established" title="is_established">is_established</a></li><li><a href="#method.is_in_early_data" title="is_in_early_data">is_in_early_data</a></li><li><a href="#method.is_path_validated" title="is_path_validated">is_path_validated</a></li><li><a href="#method.is_readable" title="is_readable">is_readable</a></li><li><a href="#method.is_resumed" title="is_resumed">is_resumed</a></li><li><a href="#method.is_server" title="is_server">is_server</a></li><li><a href="#method.is_timed_out" title="is_timed_out">is_timed_out</a></li><li><a href="#method.local_error" title="local_error">local_error</a></li><li><a href="#method.max_release_into_future" title="max_release_into_future">max_release_into_future</a></li><li><a href="#method.max_send_udp_payload_size" title="max_send_udp_payload_size">max_send_udp_payload_size</a></li><li><a href="#method.migrate" title="migrate">migrate</a></li><li><a href="#method.migrate_source" title="migrate_source">migrate_source</a></li><li><a href="#method.new_scid" title="new_scid">new_scid</a></li><li><a href="#method.on_timeout" title="on_timeout">on_timeout</a></li><li><a href="#method.pacing_enabled" title="pacing_enabled">pacing_enabled</a></li><li><a href="#method.path_event_next" title="path_event_next">path_event_next</a></li><li><a href="#method.path_stats" title="path_stats">path_stats</a></li><li><a href="#method.paths_iter" title="paths_iter">paths_iter</a></li><li><a href="#method.peer_cert" title="peer_cert">peer_cert</a></li><li><a href="#method.peer_cert_chain" title="peer_cert_chain">peer_cert_chain</a></li><li><a href="#method.peer_error" title="peer_error">peer_error</a></li><li><a href="#method.peer_streams_left_bidi" title="peer_streams_left_bidi">peer_streams_left_bidi</a></li><li><a href="#method.peer_streams_left_uni" title="peer_streams_left_uni">peer_streams_left_uni</a></li><li><a href="#method.peer_transport_params" title="peer_transport_params">peer_transport_params</a></li><li><a href="#method.pmtu" title="pmtu">pmtu</a></li><li><a href="#method.probe_path" title="probe_path">probe_path</a></li><li><a href="#method.qlog_streamer" title="qlog_streamer">qlog_streamer</a></li><li><a href="#method.readable" title="readable">readable</a></li><li><a href="#method.recv" title="recv">recv</a></li><li><a href="#method.retire_dcid" title="retire_dcid">retire_dcid</a></li><li><a href="#method.retired_scid_next" title="retired_scid_next">retired_scid_next</a></li><li><a href="#method.retired_scids" title="retired_scids">retired_scids</a></li><li><a href="#method.revalidate_pmtu" title="revalidate_pmtu">revalidate_pmtu</a></li><li><a href="#method.scids_left" title="scids_left">scids_left</a></li><li><a href="#method.send" title="send">send</a></li><li><a href="#method.send_ack_eliciting" title="send_ack_eliciting">send_ack_eliciting</a></li><li><a href="#method.send_ack_eliciting_on_path" title="send_ack_eliciting_on_path">send_ack_eliciting_on_path</a></li><li><a href="#method.send_on_path" title="send_on_path">send_on_path</a></li><li><a href="#method.send_quantum" title="send_quantum">send_quantum</a></li><li><a href="#method.send_quantum_on_path" title="send_quantum_on_path">send_quantum_on_path</a></li><li><a href="#method.server_name" title="server_name">server_name</a></li><li><a href="#method.session" title="session">session</a></li><li><a href="#method.set_cc_algorithm_in_handshake" title="set_cc_algorithm_in_handshake">set_cc_algorithm_in_handshake</a></li><li><a href="#method.set_cc_algorithm_name_in_handshake" title="set_cc_algorithm_name_in_handshake">set_cc_algorithm_name_in_handshake</a></li><li><a href="#method.set_discover_pmtu_in_handshake" title="set_discover_pmtu_in_handshake">set_discover_pmtu_in_handshake</a></li><li><a href="#method.set_enable_relaxed_loss_threshold_in_handshake" title="set_enable_relaxed_loss_threshold_in_handshake">set_enable_relaxed_loss_threshold_in_handshake</a></li><li><a href="#method.set_hystart_in_handshake" title="set_hystart_in_handshake">set_hystart_in_handshake</a></li><li><a href="#method.set_initial_congestion_window_packets_in_handshake" title="set_initial_congestion_window_packets_in_handshake">set_initial_congestion_window_packets_in_handshake</a></li><li><a href="#method.set_initial_max_streams_bidi_in_handshake" title="set_initial_max_streams_bidi_in_handshake">set_initial_max_streams_bidi_in_handshake</a></li><li><a href="#method.set_keylog" title="set_keylog">set_keylog</a></li><li><a href="#method.set_max_idle_timeout" title="set_max_idle_timeout">set_max_idle_timeout</a></li><li><a href="#method.set_max_idle_timeout_in_handshake" title="set_max_idle_timeout_in_handshake">set_max_idle_timeout_in_handshake</a></li><li><a href="#method.set_max_pacing_rate_in_handshake" title="set_max_pacing_rate_in_handshake">set_max_pacing_rate_in_handshake</a></li><li><a href="#method.set_max_send_udp_payload_size_in_handshake" title="set_max_send_udp_payload_size_in_handshake">set_max_send_udp_payload_size_in_handshake</a></li><li><a href="#method.set_pacing_in_handshake" title="set_pacing_in_handshake">set_pacing_in_handshake</a></li><li><a href="#method.set_qlog" title="set_qlog">set_qlog</a></li><li><a href="#method.set_qlog_with_level" title="set_qlog_with_level">set_qlog_with_level</a></li><li><a href="#method.set_send_capacity_factor_in_handshake" title="set_send_capacity_factor_in_handshake">set_send_capacity_factor_in_handshake</a></li><li><a href="#method.set_session" title="set_session">set_session</a></li><li><a href="#method.source_id" title="source_id">source_id</a></li><li><a href="#method.source_ids" title="source_ids">source_ids</a></li><li><a href="#method.stats" title="stats">stats</a></li><li><a href="#method.stream_capacity" title="stream_capacity">stream_capacity</a></li><li><a href="#method.stream_discard" title="stream_discard">stream_discard</a></li><li><a href="#method.stream_finished" title="stream_finished">stream_finished</a></li><li><a href="#method.stream_priority" title="stream_priority">stream_priority</a></li><li><a href="#method.stream_readable" title="stream_readable">stream_readable</a></li><li><a href="#method.stream_readable_next" title="stream_readable_next">stream_readable_next</a></li><li><a href="#method.stream_recv" title="stream_recv">stream_recv</a></li><li><a href="#method.stream_send" title="stream_send">stream_send</a></li><li><a href="#method.stream_send_zc" title="stream_send_zc">stream_send_zc</a></li><li><a href="#method.stream_shutdown" title="stream_shutdown">stream_shutdown</a></li><li><a href="#method.stream_writable" title="stream_writable">stream_writable</a></li><li><a href="#method.stream_writable_next" title="stream_writable_next">stream_writable_next</a></li><li><a href="#method.timeout" title="timeout">timeout</a></li><li><a href="#method.timeout_instant" title="timeout_instant">timeout_instant</a></li><li><a href="#method.trace_id" title="trace_id">trace_id</a></li><li><a href="#method.writable" title="writable">writable</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsMut%3CSslRef%3E-for-Connection%3CF%3E" title="AsMut&#60;SslRef&#62;">AsMut&#60;SslRef&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Connection%3CF%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-Connection%3CF%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Connection%3CF%3E" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-Connection%3CF%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-Connection%3CF%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Connection%3CF%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnsafeUnpin-for-Connection%3CF%3E" title="UnsafeUnpin">UnsafeUnpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate quiche</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">quiche</a></div><h1>Struct <span class="struct">Connection</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/quiche/lib.rs.html#1238-1505">Source</a> </span></div><pre class="rust item-decl"><code>pub struct Connection&lt;F = DefaultBufFactory&gt;<div class="where">where
    F: <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>,</div>{ <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A QUIC connection.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Connection%3CF%3E" class="impl"><a class="src rightside" href="../src/quiche/lib.rs.html#1873-8864">Source</a><a href="#impl-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F: <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>&gt; <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.set_keylog" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2188-2190">Source</a><h4 class="code-header">pub fn <a href="#method.set_keylog" class="fn">set_keylog</a>(&amp;mut self, writer: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>&gt;)</h4></section></summary><div class="docblock"><p>Sets keylog output to the designated <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Writer</code></a>.</p>
<p>This needs to be called as soon as the connection is created, to avoid
missing some early logs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_qlog" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2203-2208">Source</a><h4 class="code-header">pub fn <a href="#method.set_qlog" class="fn">set_qlog</a>(
    &amp;mut self,
    writer: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>&gt;,
    title: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    description: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
)</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>qlog</code></strong> only.</div></span></summary><div class="docblock"><p>Sets qlog output to the designated <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Writer</code></a>.</p>
<p>Only events included in <code>QlogLevel::Base</code> are written. The serialization
format is JSON-SEQ.</p>
<p>This needs to be called as soon as the connection is created, to avoid
missing some early logs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_qlog_with_level" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2221-2277">Source</a><h4 class="code-header">pub fn <a href="#method.set_qlog_with_level" class="fn">set_qlog_with_level</a>(
    &amp;mut self,
    writer: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;dyn <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>&gt;,
    title: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    description: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    qlog_level: <a class="enum" href="enum.QlogLevel.html" title="enum quiche::QlogLevel">QlogLevel</a>,
)</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>qlog</code></strong> only.</div></span></summary><div class="docblock"><p>Sets qlog output to the designated <a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Writer</code></a>.</p>
<p>Only qlog events included in the specified <code>QlogLevel</code> are written. The
serialization format is JSON-SEQ.</p>
<p>This needs to be called as soon as the connection is created, to avoid
missing some early logs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.qlog_streamer" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2282-2284">Source</a><h4 class="code-header">pub fn <a href="#method.qlog_streamer" class="fn">qlog_streamer</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut <a class="struct" href="../qlog/streamer/struct.QlogStreamer.html" title="struct qlog::streamer::QlogStreamer">QlogStreamer</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>qlog</code></strong> only.</div></span></summary><div class="docblock"><p>Returns a mutable reference to the QlogStreamer, if it exists.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_session" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2296-2316">Source</a><h4 class="code-header">pub fn <a href="#method.set_session" class="fn">set_session</a>(&amp;mut self, session: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Configures the given session for resumption.</p>
<p>On the client, this can be used to offer the given serialized session,
as returned by <a href="struct.Connection.html#method.session"><code>session()</code></a>, for resumption.</p>
<p>This must only be called immediately after creating a connection, that
is, before any packet is sent or received.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_idle_timeout" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2325-2330">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_idle_timeout" class="fn">set_max_idle_timeout</a>(&amp;mut self, v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the <code>max_idle_timeout</code> transport parameter, in milliseconds.</p>
<p>This must only be called immediately after creating a connection, that
is, before any packet is sent or received.</p>
<p>The default value is infinite, that is, no timeout is used unless
already configured when creating the connection.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_cc_algorithm_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2343-2351">Source</a><h4 class="code-header">pub fn <a href="#method.set_cc_algorithm_in_handshake" class="fn">set_cc_algorithm_in_handshake</a>(
    ssl: &amp;mut SslRef,
    algo: <a class="enum" href="enum.CongestionControlAlgorithm.html" title="enum quiche::CongestionControlAlgorithm">CongestionControlAlgorithm</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the congestion control algorithm used.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_cc_algorithm"><code>Config::set_cc_algorithm()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_cc_algorithm_name_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2391-2396">Source</a><h4 class="code-header">pub fn <a href="#method.set_cc_algorithm_name_in_handshake" class="fn">set_cc_algorithm_name_in_handshake</a>(
    ssl: &amp;mut SslRef,
    name: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the congestion control algorithm used by string.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_cc_algorithm_name"><code>Config::set_cc_algorithm_name()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_initial_congestion_window_packets_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2409-2417">Source</a><h4 class="code-header">pub fn <a href="#method.set_initial_congestion_window_packets_in_handshake" class="fn">set_initial_congestion_window_packets_in_handshake</a>(
    ssl: &amp;mut SslRef,
    packets: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets initial congestion window size in terms of packet count.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_initial_congestion_window_packets"><code>Config::set_initial_congestion_window_packets()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_enable_relaxed_loss_threshold_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2430-2438">Source</a><h4 class="code-header">pub fn <a href="#method.set_enable_relaxed_loss_threshold_in_handshake" class="fn">set_enable_relaxed_loss_threshold_in_handshake</a>(
    ssl: &amp;mut SslRef,
    enable: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Configure whether to enable relaxed loss detection on spurious loss.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_enable_relaxed_loss_threshold"><code>Config::set_enable_relaxed_loss_threshold()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_hystart_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2451-2459">Source</a><h4 class="code-header">pub fn <a href="#method.set_hystart_in_handshake" class="fn">set_hystart_in_handshake</a>(ssl: &amp;mut SslRef, v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Configures whether to enable HyStart++.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.enable_hystart"><code>Config::enable_hystart()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_pacing_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2472-2480">Source</a><h4 class="code-header">pub fn <a href="#method.set_pacing_in_handshake" class="fn">set_pacing_in_handshake</a>(ssl: &amp;mut SslRef, v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Configures whether to enable pacing.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.enable_pacing"><code>Config::enable_pacing()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_pacing_rate_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2493-2501">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_pacing_rate_in_handshake" class="fn">set_max_pacing_rate_in_handshake</a>(
    ssl: &amp;mut SslRef,
    v: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the max value for pacing rate.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_max_pacing_rate"><code>Config::set_max_pacing_rate()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_send_udp_payload_size_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2514-2522">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_send_udp_payload_size_in_handshake" class="fn">set_max_send_udp_payload_size_in_handshake</a>(
    ssl: &amp;mut SslRef,
    v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the maximum outgoing UDP payload size.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_max_send_udp_payload_size"><code>Config::set_max_send_udp_payload_size()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_send_capacity_factor_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2535-2543">Source</a><h4 class="code-header">pub fn <a href="#method.set_send_capacity_factor_in_handshake" class="fn">set_send_capacity_factor_in_handshake</a>(
    ssl: &amp;mut SslRef,
    v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the send capacity factor.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_send_capacity_factor" title="method quiche::Config::set_send_capacity_factor"><code>Config::set_send_capacity_factor()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_discover_pmtu_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2556-2564">Source</a><h4 class="code-header">pub fn <a href="#method.set_discover_pmtu_in_handshake" class="fn">set_discover_pmtu_in_handshake</a>(
    ssl: &amp;mut SslRef,
    discover: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    max_probes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Configures whether to do path MTU discovery.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.discover_pmtu"><code>Config::discover_pmtu()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_max_idle_timeout_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2577-2589">Source</a><h4 class="code-header">pub fn <a href="#method.set_max_idle_timeout_in_handshake" class="fn">set_max_idle_timeout_in_handshake</a>(ssl: &amp;mut SslRef, v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the <code>max_idle_timeout</code> transport parameter, in milliseconds.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_max_idle_timeout"><code>Config::set_max_idle_timeout()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_initial_max_streams_bidi_in_handshake" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2602-2614">Source</a><h4 class="code-header">pub fn <a href="#method.set_initial_max_streams_bidi_in_handshake" class="fn">set_initial_max_streams_bidi_in_handshake</a>(
    ssl: &amp;mut SslRef,
    v: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></summary><div class="docblock"><p>Sets the <code>initial_max_streams_bidi</code> transport parameter.</p>
<p>This function can only be called inside one of BoringSSL’s handshake
callbacks, before any packet has been sent. Calling this function any
other time will have no effect.</p>
<p>See <a href="struct.Config.html#method.set_initial_max_streams_bidi"><code>Config::set_initial_max_streams_bidi()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.recv" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#2683-2763">Source</a><h4 class="code-header">pub fn <a href="#method.recv" class="fn">recv</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], info: <a class="struct" href="struct.RecvInfo.html" title="struct quiche::RecvInfo">RecvInfo</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Processes QUIC packets received from the peer.</p>
<p>On success the number of bytes processed from the input buffer is
returned. On error the connection will be closed by calling <a href="struct.Connection.html#method.close"><code>close()</code></a>
with the appropriate error code.</p>
<p>Coalesced packets will be processed as necessary.</p>
<p>Note that the contents of the input buffer <code>buf</code> might be modified by
this function due to, for example, in-place decryption.</p>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="kw">let </span>(read, from) = socket.recv_from(<span class="kw-2">&amp;mut </span>buf).unwrap();

    <span class="kw">let </span>recv_info = quiche::RecvInfo {
        from,
        to: local,
    };

    <span class="kw">let </span>read = <span class="kw">match </span>conn.recv(<span class="kw-2">&amp;mut </span>buf[..read], recv_info) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.send" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#3724-3726">Source</a><h4 class="code-header">pub fn <a href="#method.send" class="fn">send</a>(&amp;mut self, out: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="struct.SendInfo.html" title="struct quiche::SendInfo">SendInfo</a>)&gt;</h4></section></summary><div class="docblock"><p>Writes a single QUIC packet to be sent to the peer.</p>
<p>On success the number of bytes written to the output buffer is
returned, or <a href="enum.Error.html#variant.Done"><code>Done</code></a> if there was nothing to write.</p>
<p>The application should call <code>send()</code> multiple times until <a href="enum.Error.html#variant.Done"><code>Done</code></a> is
returned, indicating that there are no more packets to send. It is
recommended that <code>send()</code> be called in the following cases:</p>
<ul>
<li>
<p>When the application receives QUIC packets from the peer (that is,
any time <a href="struct.Connection.html#method.recv"><code>recv()</code></a> is also called).</p>
</li>
<li>
<p>When the connection timer expires (that is, any time <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a>
is also called).</p>
</li>
<li>
<p>When the application sends data to the peer (for example, any time
<a href="struct.Connection.html#method.stream_send"><code>stream_send()</code></a> or <a href="struct.Connection.html#method.stream_shutdown"><code>stream_shutdown()</code></a> are called).</p>
</li>
<li>
<p>When the application receives data from the peer (for example any
time <a href="struct.Connection.html#method.stream_recv"><code>stream_recv()</code></a> is called).</p>
</li>
</ul>
<p>Once <a href="struct.Connection.html#method.is_draining"><code>is_draining()</code></a> returns <code>true</code>, it is no longer necessary to call
<code>send()</code> and all calls will return <a href="enum.Error.html#variant.Done"><code>Done</code></a>.</p>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="kw">let </span>(write, send_info) = <span class="kw">match </span>conn.send(<span class="kw-2">&amp;mut </span>out) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
            <span class="comment">// Done writing.
            </span><span class="kw">break</span>;
        },

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };

    socket.send_to(<span class="kw-2">&amp;</span>out[..write], <span class="kw-2">&amp;</span>send_info.to).unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.send_on_path" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#3811-3954">Source</a><h4 class="code-header">pub fn <a href="#method.send_on_path" class="fn">send_on_path</a>(
    &amp;mut self,
    out: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
    from: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>&gt;,
    to: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>&gt;,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="struct" href="struct.SendInfo.html" title="struct quiche::SendInfo">SendInfo</a>)&gt;</h4></section></summary><div class="docblock"><p>Writes a single QUIC packet to be sent to the peer from the specified
local address <code>from</code> to the destination address <code>to</code>.</p>
<p>The behavior of this method differs depending on the value of the <code>from</code>
and <code>to</code> parameters:</p>
<ul>
<li>
<p>If both are <code>Some</code>, then the method only consider the 4-tuple
(<code>from</code>, <code>to</code>). Application can monitor the 4-tuple availability,
either by monitoring <a href="struct.Connection.html#method.path_event_next"><code>path_event_next()</code></a> events or by relying on
the <a href="struct.Connection.html#method.paths_iter"><code>paths_iter()</code></a> method. If the provided 4-tuple does not exist
on the connection (anymore), it returns an <a href="enum.Error.html#InvalidState"><code>InvalidState</code></a>.</p>
</li>
<li>
<p>If <code>from</code> is <code>Some</code> and <code>to</code> is <code>None</code>, then the method only
considers sending packets on paths having <code>from</code> as local address.</p>
</li>
<li>
<p>If <code>to</code> is <code>Some</code> and <code>from</code> is <code>None</code>, then the method only
considers sending packets on paths having <code>to</code> as peer address.</p>
</li>
<li>
<p>If both are <code>None</code>, all available paths are considered.</p>
</li>
</ul>
<p>On success the number of bytes written to the output buffer is
returned, or <a href="enum.Error.html#variant.Done"><code>Done</code></a> if there was nothing to write.</p>
<p>The application should call <code>send_on_path()</code> multiple times until
<a href="enum.Error.html#variant.Done"><code>Done</code></a> is returned, indicating that there are no more packets to
send. It is recommended that <code>send_on_path()</code> be called in the
following cases:</p>
<ul>
<li>
<p>When the application receives QUIC packets from the peer (that is,
any time <a href="struct.Connection.html#method.recv"><code>recv()</code></a> is also called).</p>
</li>
<li>
<p>When the connection timer expires (that is, any time <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a>
is also called).</p>
</li>
<li>
<p>When the application sends data to the peer (for examples, any time
<a href="struct.Connection.html#method.stream_send"><code>stream_send()</code></a> or <a href="struct.Connection.html#method.stream_shutdown"><code>stream_shutdown()</code></a> are called).</p>
</li>
<li>
<p>When the application receives data from the peer (for example any
time <a href="struct.Connection.html#method.stream_recv"><code>stream_recv()</code></a> is called).</p>
</li>
</ul>
<p>Once <a href="struct.Connection.html#method.is_draining"><code>is_draining()</code></a> returns <code>true</code>, it is no longer necessary to call
<code>send_on_path()</code> and all calls will return <a href="enum.Error.html#variant.Done"><code>Done</code></a>.</p>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="kw">let </span>(write, send_info) = <span class="kw">match </span>conn.send_on_path(<span class="kw-2">&amp;mut </span>out, <span class="prelude-val">Some</span>(local), <span class="prelude-val">Some</span>(peer)) {
        <span class="prelude-val">Ok</span>(v) =&gt; v,

        <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
            <span class="comment">// Done writing.
            </span><span class="kw">break</span>;
        },

        <span class="prelude-val">Err</span>(e) =&gt; {
            <span class="comment">// An error occurred, handle it.
            </span><span class="kw">break</span>;
        },
    };

    socket.send_to(<span class="kw-2">&amp;</span>out[..write], <span class="kw-2">&amp;</span>send_info.to).unwrap();
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_next_release_time" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5267-5275">Source</a><h4 class="code-header">pub fn <a href="#method.get_next_release_time" class="fn">get_next_release_time</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;ReleaseDecision&gt;</h4></section></summary><div class="docblock"><p>Returns the desired send time for the next packet.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.gcongestion_enabled" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5279-5281">Source</a><h4 class="code-header">pub fn <a href="#method.gcongestion_enabled" class="fn">gcongestion_enabled</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns whether gcongestion is enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max_release_into_future" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5287-5294">Source</a><h4 class="code-header">pub fn <a href="#method.max_release_into_future" class="fn">max_release_into_future</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a></h4></section></summary><div class="docblock"><p>Returns the maximum pacing into the future.</p>
<p>Equals 1/8 of the smoothed RTT, but at least 1ms and not greater than
5ms.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pacing_enabled" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5298-5300">Source</a><h4 class="code-header">pub fn <a href="#method.pacing_enabled" class="fn">pacing_enabled</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether pacing is enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_quantum" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5311-5316">Source</a><h4 class="code-header">pub fn <a href="#method.send_quantum" class="fn">send_quantum</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the size of the send quantum, in bytes.</p>
<p>This represents the maximum size of a packet burst as determined by the
congestion control algorithm in use.</p>
<p>Applications can, for example, use it in conjunction with segmentation
offloading mechanisms as the maximum limit for outgoing aggregates of
multiple packets.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_quantum_on_path" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5329-5337">Source</a><h4 class="code-header">pub fn <a href="#method.send_quantum_on_path" class="fn">send_quantum_on_path</a>(
    &amp;self,
    local_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
    peer_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the size of the send quantum over the given 4-tuple, in bytes.</p>
<p>This represents the maximum size of a packet burst as determined by the
congestion control algorithm in use.</p>
<p>Applications can, for example, use it in conjunction with segmentation
offloading mechanisms as the maximum limit for outgoing aggregates of
multiple packets.</p>
<p>If the (<code>local_addr</code>, peer_addr`) 4-tuple relates to a non-existing
path, this method returns 0.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_recv" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5369-5373">Source</a><h4 class="code-header">pub fn <a href="#method.stream_recv" class="fn">stream_recv</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    out: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)&gt;</h4></section></summary><div class="docblock"><p>Reads contiguous data from a stream into the provided slice.</p>
<p>The slice must be sized by the caller and will be populated up to its
capacity.</p>
<p>On success the amount of bytes read and a flag indicating the fin state
is returned as a tuple, or <a href="enum.Error.html#variant.Done"><code>Done</code></a> if there is no data to read.</p>
<p>Reading data from a stream may trigger queueing of control messages
(e.g. MAX_STREAM_DATA). <a href="struct.Connection.html#method.send"><code>send()</code></a> should be called afterwards.</p>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">while let </span><span class="prelude-val">Ok</span>((read, fin)) = conn.stream_recv(stream_id, <span class="kw-2">&amp;mut </span>buf) {
    <span class="macro">println!</span>(<span class="string">"Got {} bytes on stream {}"</span>, read, stream_id);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.stream_discard" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5402-5406">Source</a><h4 class="code-header">pub fn <a href="#method.stream_discard" class="fn">stream_discard</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>)&gt;</h4></section></summary><div class="docblock"><p>Discard contiguous data from a stream without copying.</p>
<p>On success the amount of bytes discarded and a flag indicating the fin
state is returned as a tuple, or <a href="enum.Error.html#variant.Done"><code>Done</code></a> if there is no data to
discard.</p>
<p>Discarding data from a stream may trigger queueing of control messages
(e.g. MAX_STREAM_DATA). <a href="struct.Connection.html#method.send"><code>send()</code></a> should be called afterwards.</p>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">while let </span><span class="prelude-val">Ok</span>((read, fin)) = conn.stream_discard(stream_id, <span class="number">1</span>) {
    <span class="macro">println!</span>(<span class="string">"Discarded {} byte(s) on stream {}"</span>, read, stream_id);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.stream_send" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5563-5577">Source</a><h4 class="code-header">pub fn <a href="#method.stream_send" class="fn">stream_send</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],
    fin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Writes data to a stream.</p>
<p>On success the number of bytes written is returned, or <a href="enum.Error.html#variant.Done"><code>Done</code></a> if no
data was written (e.g. because the stream has no capacity).</p>
<p>Applications can provide a 0-length buffer with the fin flag set to
true. This will lead to a 0-length FIN STREAM frame being sent at the
latest offset. The <code>Ok(0)</code> value is only returned when the application
provided a 0-length buffer.</p>
<p>In addition, if the peer has signalled that it doesn’t want to receive
any more data from this stream by sending the <code>STOP_SENDING</code> frame, the
<a href="enum.Error.html#variant.StreamStopped"><code>StreamStopped</code></a> error will be returned instead of any data.</p>
<p>Note that in order to avoid buffering an infinite amount of data in the
stream’s send buffer, streams are only allowed to buffer outgoing data
up to the amount that the peer allows it to send (that is, up to the
stream’s outgoing flow control capacity).</p>
<p>This means that the number of written bytes returned can be lower than
the length of the input buffer when the stream doesn’t have enough
capacity for the operation to complete. The application should retry the
operation once the stream is reported as writable again.</p>
<p>Applications should call this method only after the handshake is
completed (whenever <a href="struct.Connection.html#method.is_established"><code>is_established()</code></a> returns <code>true</code>) or during
early data if enabled (whenever <a href="struct.Connection.html#method.is_in_early_data"><code>is_in_early_data()</code></a> returns <code>true</code>).</p>
<h6 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>conn.stream_send(stream_id, <span class="string">b"hello"</span>, <span class="bool-val">true</span>)<span class="question-mark">?</span>;</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.stream_send_zc" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5587-5606">Source</a><h4 class="code-header">pub fn <a href="#method.stream_send_zc" class="fn">stream_send_zc</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    buf: F::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>,
    len: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;,
    fin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;F::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>&gt;)&gt;<div class="where">where
    F::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>: <a class="trait" href="trait.BufSplit.html" title="trait quiche::BufSplit">BufSplit</a>,</div></h4></section></summary><div class="docblock"><p>Writes data to a stream with zero copying, instead, it appends the
provided buffer directly to the send queue if the capacity allows
it.</p>
<p>When a partial write happens (including when <a href="enum.Error.html#variant.Done" title="variant quiche::Error::Done"><code>Error::Done</code></a> is
returned) the remaining (unwritten) buffer will also be returned.
The application should retry the operation once the stream is
reported as writable again.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_priority" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5784-5818">Source</a><h4 class="code-header">pub fn <a href="#method.stream_priority" class="fn">stream_priority</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    urgency: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>,
    incremental: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the priority for a stream.</p>
<p>A stream’s priority determines the order in which stream data is sent
on the wire (streams with lower priority are sent first). Streams are
created with a default priority of <code>127</code>.</p>
<p>The target stream is created if it did not exist before calling this
method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_shutdown" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5845-5929">Source</a><h4 class="code-header">pub fn <a href="#method.stream_shutdown" class="fn">stream_shutdown</a>(
    &amp;mut self,
    stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
    direction: <a class="enum" href="enum.Shutdown.html" title="enum quiche::Shutdown">Shutdown</a>,
    err: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Shuts down reading or writing from/to the specified stream.</p>
<p>When the <code>direction</code> argument is set to <a href="enum.Shutdown.html#variant.Read"><code>Shutdown::Read</code></a>, outstanding
data in the stream’s receive buffer is dropped, and no additional data
is added to it. Data received after calling this method is still
validated and acked but not stored, and <a href="struct.Connection.html#method.stream_recv"><code>stream_recv()</code></a> will not
return it to the application. In addition, a <code>STOP_SENDING</code> frame will
be sent to the peer to signal it to stop sending data.</p>
<p>When the <code>direction</code> argument is set to <a href="enum.Shutdown.html#variant.Write"><code>Shutdown::Write</code></a>, outstanding
data in the stream’s send buffer is dropped, and no additional data is
added to it. Data passed to <a href="struct.Connection.html#method.stream_send"><code>stream_send()</code></a> after calling this method
will be ignored. In addition, a <code>RESET_STREAM</code> frame will be sent to the
peer to signal the reset.</p>
<p>Locally-initiated unidirectional streams can only be closed in the
<a href="enum.Shutdown.html#variant.Write"><code>Shutdown::Write</code></a> direction. Remotely-initiated unidirectional streams
can only be closed in the <a href="enum.Shutdown.html#variant.Read"><code>Shutdown::Read</code></a> direction. Using an
incorrect direction will return <a href="enum.Error.html#variant.InvalidStreamState"><code>InvalidStreamState</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_capacity" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5944-5969">Source</a><h4 class="code-header">pub fn <a href="#method.stream_capacity" class="fn">stream_capacity</a>(&amp;mut self, stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the stream’s send capacity in bytes.</p>
<p>If the specified stream doesn’t exist (including when it has already
been completed and closed), the <a href="enum.Error.html#variant.InvalidStreamState"><code>InvalidStreamState</code></a> error will be
returned.</p>
<p>In addition, if the peer has signalled that it doesn’t want to receive
any more data from this stream by sending the <code>STOP_SENDING</code> frame, the
<a href="enum.Error.html#variant.StreamStopped"><code>StreamStopped</code></a> error will be returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_readable_next" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5983-5989">Source</a><h4 class="code-header">pub fn <a href="#method.stream_readable_next" class="fn">stream_readable_next</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next stream that has data to read.</p>
<p>Note that once returned by this method, a stream ID will not be returned
again until it is “re-armed”.</p>
<p>The application will need to read all of the pending data on the stream,
and new data has to be received before the stream is reported again.</p>
<p>This is unlike the <a href="struct.Connection.html#method.readable"><code>readable()</code></a> method, that returns the same list of
readable streams when called multiple times in succession.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_readable" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#5992-6000">Source</a><h4 class="code-header">pub fn <a href="#method.stream_readable" class="fn">stream_readable</a>(&amp;self, stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the stream has data that can be read.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_writable_next" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6017-6051">Source</a><h4 class="code-header">pub fn <a href="#method.stream_writable_next" class="fn">stream_writable_next</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next stream that can be written to.</p>
<p>Note that once returned by this method, a stream ID will not be returned
again until it is “re-armed”.</p>
<p>This is unlike the <a href="struct.Connection.html#method.writable"><code>writable()</code></a> method, that returns the same list of
writable streams when called multiple times in succession. It is not
advised to use both <code>stream_writable_next()</code> and <a href="struct.Connection.html#method.writable"><code>writable()</code></a> on the
same connection, as it may lead to unexpected results.</p>
<p>The <a href="struct.Connection.html#method.stream_writable"><code>stream_writable()</code></a> method can also be used to fine-tune when a
stream is reported as writable again.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_writable" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6076-6116">Source</a><h4 class="code-header">pub fn <a href="#method.stream_writable" class="fn">stream_writable</a>(&amp;mut self, stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns true if the stream has enough send capacity.</p>
<p>When <code>len</code> more bytes can be buffered into the given stream’s send
buffer, <code>true</code> will be returned, <code>false</code> otherwise.</p>
<p>In the latter case, if the additional data can’t be buffered due to
flow control limits, the peer will also be notified, and a “low send
watermark” will be set for the stream, such that it is not going to be
reported as writable again by <a href="struct.Connection.html#method.stream_writable_next"><code>stream_writable_next()</code></a> until its send
capacity reaches <code>len</code>.</p>
<p>If the specified stream doesn’t exist (including when it has already
been completed and closed), the <a href="enum.Error.html#variant.InvalidStreamState"><code>InvalidStreamState</code></a> error will be
returned.</p>
<p>In addition, if the peer has signalled that it doesn’t want to receive
any more data from this stream by sending the <code>STOP_SENDING</code> frame, the
<a href="enum.Error.html#variant.StreamStopped"><code>StreamStopped</code></a> error will be returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stream_finished" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6127-6135">Source</a><h4 class="code-header">pub fn <a href="#method.stream_finished" class="fn">stream_finished</a>(&amp;self, stream_id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if all the data has been read from the specified stream.</p>
<p>This instructs the application that all the data received from the
peer on the stream has been read, and there won’t be anymore in the
future.</p>
<p>Basically this returns true when the peer either set the <code>fin</code> flag
for the stream, or sent <code>RESET_STREAM</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_streams_left_bidi" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6143-6145">Source</a><h4 class="code-header">pub fn <a href="#method.peer_streams_left_bidi" class="fn">peer_streams_left_bidi</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns the number of bidirectional streams that can be created
before the peer’s stream count limit is reached.</p>
<p>This can be useful to know if it’s possible to create a bidirectional
stream without trying it first.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_streams_left_uni" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6153-6155">Source</a><h4 class="code-header">pub fn <a href="#method.peer_streams_left_uni" class="fn">peer_streams_left_uni</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns the number of unidirectional streams that can be created
before the peer’s stream count limit is reached.</p>
<p>This can be useful to know if it’s possible to create a unidirectional
stream without trying it first.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.readable" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6184-6186">Source</a><h4 class="code-header">pub fn <a href="#method.readable" class="fn">readable</a>(&amp;self) -&gt; <a class="struct" href="struct.StreamIter.html" title="struct quiche::StreamIter">StreamIter</a> <a href="#" class="tooltip" data-notable-ty="StreamIter">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over streams that have outstanding data to read.</p>
<p>Note that the iterator will only include streams that were readable at
the time the iterator itself was created (i.e. when <code>readable()</code> was
called). To account for newly readable streams, the iterator needs to
be created again.</p>
<h6 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate over readable streams.
</span><span class="kw">for </span>stream_id <span class="kw">in </span>conn.readable() {
    <span class="comment">// Stream is readable, read until there's no more data.
    </span><span class="kw">while let </span><span class="prelude-val">Ok</span>((read, fin)) = conn.stream_recv(stream_id, <span class="kw-2">&amp;mut </span>buf) {
        <span class="macro">println!</span>(<span class="string">"Got {} bytes on stream {}"</span>, read, stream_id);
    }
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.writable" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6227-6235">Source</a><h4 class="code-header">pub fn <a href="#method.writable" class="fn">writable</a>(&amp;self) -&gt; <a class="struct" href="struct.StreamIter.html" title="struct quiche::StreamIter">StreamIter</a> <a href="#" class="tooltip" data-notable-ty="StreamIter">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over streams that can be written in priority order.</p>
<p>The priority order is based on RFC 9218 scheduling recommendations.
Stream priority can be controlled using <a href="struct.Connection.html#method.stream_priority"><code>stream_priority()</code></a>. In order
to support fairness requirements, each time this method is called,
internal state is updated. Therefore the iterator ordering can change
between calls, even if no streams were added or removed.</p>
<p>A “writable” stream is a stream that has enough flow control capacity to
send data to the peer. To avoid buffering an infinite amount of data,
streams are only allowed to buffer outgoing data up to the amount that
the peer allows to send.</p>
<p>Note that the iterator will only include streams that were writable at
the time the iterator itself was created (i.e. when <code>writable()</code> was
called). To account for newly writable streams, the iterator needs to be
created again.</p>
<h6 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate over writable streams.
</span><span class="kw">for </span>stream_id <span class="kw">in </span>conn.writable() {
    <span class="comment">// Stream is writable, write some data.
    </span><span class="kw">if let </span><span class="prelude-val">Ok</span>(written) = conn.stream_send(stream_id, <span class="kw-2">&amp;</span>buf, <span class="bool-val">false</span>) {
        <span class="macro">println!</span>(<span class="string">"Written {} bytes on stream {}"</span>, written, stream_id);
    }
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.max_send_udp_payload_size" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6250-6268">Source</a><h4 class="code-header">pub fn <a href="#method.max_send_udp_payload_size" class="fn">max_send_udp_payload_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the maximum possible size of egress UDP payloads.</p>
<p>This is the maximum size of UDP payloads that can be sent, and depends
on both the configured maximum send payload size of the local endpoint
(as configured with <a href="struct.Config.html#method.set_max_send_udp_payload_size"><code>set_max_send_udp_payload_size()</code></a>), as well as
the transport parameter advertised by the remote peer.</p>
<p>Note that this value can change during the lifetime of the connection,
but should remain stable across consecutive calls to <a href="struct.Connection.html#method.send"><code>send()</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_ack_eliciting" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6281-6287">Source</a><h4 class="code-header">pub fn <a href="#method.send_ack_eliciting" class="fn">send_ack_eliciting</a>(&amp;mut self) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Schedule an ack-eliciting packet on the active path.</p>
<p>QUIC packets might not contain ack-eliciting frames during normal
operating conditions. If the packet would already contain
ack-eliciting frames, this method does not change any behavior.
However, if the packet would not ordinarily contain ack-eliciting
frames, this method ensures that a PING frame sent.</p>
<p>Calling this method multiple times before <a href="struct.Connection.html#method.send"><code>send()</code></a> has no effect.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_ack_eliciting_on_path" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6296-6308">Source</a><h4 class="code-header">pub fn <a href="#method.send_ack_eliciting_on_path" class="fn">send_ack_eliciting_on_path</a>(
    &amp;mut self,
    local: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
    peer: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Schedule an ack-eliciting packet on the specified path.</p>
<p>See <a href="struct.Connection.html#method.send_ack_eliciting"><code>send_ack_eliciting()</code></a> for more detail. <a href="enum.Error.html#variant.InvalidState"><code>InvalidState</code></a> is
returned if there is no record of the path.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6339-6352">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv" class="fn">dgram_recv</a>(&amp;mut self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Reads the first received DATAGRAM.</p>
<p>On success the DATAGRAM’s data is returned along with its size.</p>
<p><a href="enum.Error.html#variant.Done"><code>Done</code></a> is returned if there is no data to read.</p>
<p><a href="enum.Error.html#variant.BufferTooShort"><code>BufferTooShort</code></a> is returned if the provided buffer is too small for
the DATAGRAM.</p>
<h6 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>dgram_buf = [<span class="number">0</span>; <span class="number">512</span>];
<span class="kw">while let </span><span class="prelude-val">Ok</span>((len)) = conn.dgram_recv(<span class="kw-2">&amp;mut </span>dgram_buf) {
    <span class="macro">println!</span>(<span class="string">"Got {} bytes of DATAGRAM"</span>, len);
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv_vec" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6361-6367">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv_vec" class="fn">dgram_recv_vec</a>(&amp;mut self) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Reads the first received DATAGRAM.</p>
<p>This is the same as <a href="struct.Connection.html#method.dgram_recv"><code>dgram_recv()</code></a> but returns the DATAGRAM as a
<code>Vec&lt;u8&gt;</code> instead of copying into the provided buffer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv_peek" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6383-6385">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv_peek" class="fn">dgram_recv_peek</a>(&amp;self, buf: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Reads the first received DATAGRAM without removing it from the queue.</p>
<p>On success the DATAGRAM’s data is returned along with the actual number
of bytes peeked. The requested length cannot exceed the DATAGRAM’s
actual length.</p>
<p><a href="enum.Error.html#variant.Done"><code>Done</code></a> is returned if there is no data to read.</p>
<p><a href="enum.Error.html#variant.BufferTooShort"><code>BufferTooShort</code></a> is returned if the provided buffer is smaller the
number of bytes to peek.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv_front_len" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6389-6391">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv_front_len" class="fn">dgram_recv_front_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length of the first stored DATAGRAM.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv_queue_len" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6395-6397">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv_queue_len" class="fn">dgram_recv_queue_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of items in the DATAGRAM receive queue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_recv_queue_byte_size" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6401-6403">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_recv_queue_byte_size" class="fn">dgram_recv_queue_byte_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total size of all items in the DATAGRAM receive queue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_send_queue_len" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6407-6409">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_send_queue_len" class="fn">dgram_send_queue_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of items in the DATAGRAM send queue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_send_queue_byte_size" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6413-6415">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_send_queue_byte_size" class="fn">dgram_send_queue_byte_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total size of all items in the DATAGRAM send queue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_dgram_send_queue_full" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6419-6421">Source</a><h4 class="code-header">pub fn <a href="#method.is_dgram_send_queue_full" class="fn">is_dgram_send_queue_full</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether or not the DATAGRAM send queue is full.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_dgram_recv_queue_full" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6425-6427">Source</a><h4 class="code-header">pub fn <a href="#method.is_dgram_recv_queue_full" class="fn">is_dgram_recv_queue_full</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether or not the DATAGRAM recv queue is full.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_send" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6461-6483">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_send" class="fn">dgram_send</a>(&amp;mut self, buf: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Sends data in a DATAGRAM frame.</p>
<p><a href="enum.Error.html#variant.Done"><code>Done</code></a> is returned if no data was written.
<a href="enum.Error.html#variant.InvalidState"><code>InvalidState</code></a> is returned if the peer does not support DATAGRAM.
<a href="enum.Error.html#variant.BufferTooShort"><code>BufferTooShort</code></a> is returned if the DATAGRAM frame length is larger
than peer’s supported DATAGRAM frame length. Use
<a href="struct.Connection.html#method.dgram_max_writable_len"><code>dgram_max_writable_len()</code></a> to get the largest supported DATAGRAM
frame length.</p>
<p>Note that there is no flow control of DATAGRAM frames, so in order to
avoid buffering an infinite amount of frames we apply an internal
limit.</p>
<h6 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>conn.dgram_send(<span class="string">b"hello"</span>)<span class="question-mark">?</span>;</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_send_vec" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6491-6513">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_send_vec" class="fn">dgram_send_vec</a>(&amp;mut self, buf: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Sends data in a DATAGRAM frame.</p>
<p>This is the same as <a href="struct.Connection.html#method.dgram_send"><code>dgram_send()</code></a> but takes a <code>Vec&lt;u8&gt;</code> instead of
a slice.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_purge_outgoing" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6532-6534">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_purge_outgoing" class="fn">dgram_purge_outgoing</a>&lt;FN: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;(&amp;mut self, f: FN)</h4></section></summary><div class="docblock"><p>Purges queued outgoing DATAGRAMs matching the predicate.</p>
<p>In other words, remove all elements <code>e</code> such that <code>f(&amp;e)</code> returns true.</p>
<h6 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>conn.dgram_send(<span class="string">b"hello"</span>)<span class="question-mark">?</span>;
conn.dgram_purge_outgoing(<span class="kw-2">&amp;</span>|d: <span class="kw-2">&amp;</span>[u8]| -&gt; bool { d[<span class="number">0</span>] == <span class="number">0 </span>});</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.dgram_max_writable_len" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6559-6583">Source</a><h4 class="code-header">pub fn <a href="#method.dgram_max_writable_len" class="fn">dgram_max_writable_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the maximum DATAGRAM payload that can be sent.</p>
<p><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> is returned if the peer hasn’t advertised a maximum DATAGRAM
frame size.</p>
<h6 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if let </span><span class="prelude-val">Some</span>(payload_size) = conn.dgram_max_writable_len() {
    <span class="kw">if </span>payload_size &gt; <span class="number">5 </span>{
        conn.dgram_send(<span class="string">b"hello"</span>)<span class="question-mark">?</span>;
    }
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.timeout_instant" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6598-6628">Source</a><h4 class="code-header">pub fn <a href="#method.timeout_instant" class="fn">timeout_instant</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/std/time/struct.Instant.html" title="struct std::time::Instant">Instant</a>&gt;</h4></section></summary><div class="docblock"><p>Returns when the next timeout event will occur.</p>
<p>Once the timeout Instant has been reached, the <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a> method
should be called. A timeout of <code>None</code> means that the timer should be
disarmed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.timeout" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6636-6646">Source</a><h4 class="code-header">pub fn <a href="#method.timeout" class="fn">timeout</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the amount of time until the next timeout event.</p>
<p>Once the given duration has elapsed, the <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a> method should
be called. A timeout of <code>None</code> means that the timer should be disarmed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.on_timeout" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6651-6736">Source</a><h4 class="code-header">pub fn <a href="#method.on_timeout" class="fn">on_timeout</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Processes a timeout event.</p>
<p>If no timeout has occurred it does nothing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.probe_path" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6768-6781">Source</a><h4 class="code-header">pub fn <a href="#method.probe_path" class="fn">probe_path</a>(
    &amp;mut self,
    local_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
    peer_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Requests the stack to perform path validation of the proposed 4-tuple.</p>
<p>Probing new paths requires spare Connection IDs at both the host and the
peer sides. If it is not the case, it raises an <a href="enum.Error.html#OutOfIdentifiers"><code>OutOfIdentifiers</code></a>.</p>
<p>The probing of new addresses can only be done by the client. The server
can only probe network paths that were previously advertised by
<a href="enum.PathEvent.html#variant.New"><code>PathEvent::New</code></a>. If the server tries to probe such an unseen network
path, this call raises an <a href="enum.Error.html#InvalidState"><code>InvalidState</code></a>.</p>
<p>The caller might also want to probe an existing path. In such case, it
triggers a PATH_CHALLENGE frame, but it does not require spare CIDs.</p>
<p>A server always probes a new path it observes. Calling this method is
hence not required to validate a new path. However, a server can still
request an additional path validation of the proposed 4-tuple.</p>
<p>Calling this method several times before calling <a href="struct.Connection.html#method.send"><code>send()</code></a> or
<a href="struct.Connection.html#method.send_on_path"><code>send_on_path()</code></a> results in a single probe being generated. An
application wanting to send multiple in-flight probes must call this
method again after having sent packets.</p>
<p>Returns the Destination Connection ID sequence number associated to that
path.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.migrate_source" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6791-6794">Source</a><h4 class="code-header">pub fn <a href="#method.migrate_source" class="fn">migrate_source</a>(&amp;mut self, local_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Migrates the connection to a new local address <code>local_addr</code>.</p>
<p>The behavior is similar to <a href="struct.Connection.html#method.migrate"><code>migrate()</code></a>, with the nuance that the
connection only changes the local address, but not the peer one.</p>
<p>See <a href="struct.Connection.html#method.migrate"><code>migrate()</code></a> for the full specification of this method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.migrate" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6810-6870">Source</a><h4 class="code-header">pub fn <a href="#method.migrate" class="fn">migrate</a>(
    &amp;mut self,
    local_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
    peer_addr: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Migrates the connection over the given network path between <code>local_addr</code>
and <code>peer_addr</code>.</p>
<p>Connection migration can only be initiated by the client. Calling this
method as a server returns <a href="enum.Error.html#InvalidState"><code>InvalidState</code></a>.</p>
<p>To initiate voluntary migration, there should be enough Connection IDs
at both sides. If this requirement is not satisfied, this call returns
<a href="enum.Error.html#OutOfIdentifiers"><code>OutOfIdentifiers</code></a>.</p>
<p>Returns the Destination Connection ID associated to that migrated path.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_scid" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6904-6914">Source</a><h4 class="code-header">pub fn <a href="#method.new_scid" class="fn">new_scid</a>(
    &amp;mut self,
    scid: &amp;<a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a>&lt;'_&gt;,
    reset_token: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u128.html">u128</a>,
    retire_if_needed: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Provides additional source Connection IDs that the peer can use to reach
this host.</p>
<p>This triggers sending NEW_CONNECTION_ID frames if the provided Source
Connection ID is not already present. In the case the caller tries to
reuse a Connection ID with a different reset token, this raises an
<code>InvalidState</code>.</p>
<p>At any time, the peer cannot have more Destination Connection IDs than
the maximum number of active Connection IDs it negotiated. In such case
(i.e., when <a href="struct.Connection.html#method.scids_left"><code>scids_left()</code></a> returns 0), if the host agrees to
request the removal of previous connection IDs, it sets the
<code>retire_if_needed</code> parameter. Otherwise, an <a href="enum.Error.html#IdLimit"><code>IdLimit</code></a> is returned.</p>
<p>Note that setting <code>retire_if_needed</code> does not prevent this function from
returning an <a href="enum.Error.html#IdLimit"><code>IdLimit</code></a> in the case the caller wants to retire still
unannounced Connection IDs.</p>
<p>The caller is responsible for ensuring that the provided <code>scid</code> is not
repeated several times over the connection. quiche ensures that as long
as the provided Connection ID is still in use (i.e., not retired), it
does not assign a different sequence number.</p>
<p>Note that if the host uses zero-length Source Connection IDs, it cannot
advertise Source Connection IDs and calling this method returns an
<a href="enum.Error.html#InvalidState"><code>InvalidState</code></a>.</p>
<p>Returns the sequence number associated to the provided Connection ID.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.active_scids" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6918-6920">Source</a><h4 class="code-header">pub fn <a href="#method.active_scids" class="fn">active_scids</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of source Connection IDs that are active. This is
only meaningful if the host uses non-zero length Source Connection IDs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.scids_left" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6934-6941">Source</a><h4 class="code-header">pub fn <a href="#method.scids_left" class="fn">scids_left</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of source Connection IDs that should be provided
to the peer without exceeding the limit it advertised.</p>
<p>This will automatically limit the number of Connection IDs to the
minimum between the locally configured active connection ID limit,
and the one sent by the peer.</p>
<p>To obtain the maximum possible value allowed by the peer an application
can instead inspect the <a href="struct.Stats.html#structfield.peer_active_conn_id_limit"><code>peer_active_conn_id_limit</code></a> value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retire_dcid" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#6962-6999">Source</a><h4 class="code-header">pub fn <a href="#method.retire_dcid" class="fn">retire_dcid</a>(&amp;mut self, dcid_seq: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Requests the retirement of the destination Connection ID used by the
host to reach its peer.</p>
<p>This triggers sending RETIRE_CONNECTION_ID frames.</p>
<p>If the application tries to retire a non-existing Destination Connection
ID sequence number, or if it uses zero-length Destination Connection ID,
this method returns an <a href="enum.Error.html#InvalidState"><code>InvalidState</code></a>.</p>
<p>At any time, the host must have at least one Destination ID. If the
application tries to retire the last one, or if the caller tries to
retire the destination Connection ID used by the current active path
while having neither spare Destination Connection IDs nor validated
network paths, this method returns an <a href="enum.Error.html#OutOfIdentifiers"><code>OutOfIdentifiers</code></a>. This
behavior prevents the caller from stalling the connection due to the
lack of validated path to send non-probing packets.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.path_event_next" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7012-7014">Source</a><h4 class="code-header">pub fn <a href="#method.path_event_next" class="fn">path_event_next</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.PathEvent.html" title="enum quiche::PathEvent">PathEvent</a>&gt;</h4></section></summary><div class="docblock"><p>Processes path-specific events.</p>
<p>On success it returns a <a href="enum.PathEvent.html"><code>PathEvent</code></a>, or <code>None</code> when there are no
events to report. Please refer to <a href="enum.PathEvent.html"><code>PathEvent</code></a> for the exhaustive event
list.</p>
<p>Note that all events are edge-triggered, meaning that once reported they
will not be reported again by calling this method again, until the event
is re-armed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retired_scids" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7017-7019">Source</a><h4 class="code-header">pub fn <a href="#method.retired_scids" class="fn">retired_scids</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of source Connection IDs that are retired.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retired_scid_next" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7027-7029">Source</a><h4 class="code-header">pub fn <a href="#method.retired_scid_next" class="fn">retired_scid_next</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a>&lt;'static&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a source <code>ConnectionId</code> that has been retired.</p>
<p>On success it returns a <a href="struct.ConnectionId.html"><code>ConnectionId</code></a>, or <code>None</code> when there are no
more retired connection IDs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.available_dcids" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7036-7038">Source</a><h4 class="code-header">pub fn <a href="#method.available_dcids" class="fn">available_dcids</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of spare Destination Connection IDs, i.e.,
Destination Connection IDs that are still unused.</p>
<p>Note that this function returns 0 if the host uses zero length
Destination Connection IDs.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.paths_iter" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7087-7102">Source</a><h4 class="code-header">pub fn <a href="#method.paths_iter" class="fn">paths_iter</a>(&amp;self, from: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>) -&gt; <a class="struct" href="struct.SocketAddrIter.html" title="struct quiche::SocketAddrIter">SocketAddrIter</a> <a href="#" class="tooltip" data-notable-ty="SocketAddrIter">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns an iterator over destination <code>SockAddr</code>s whose association
with <code>from</code> forms a known QUIC path on which packets can be sent to.</p>
<p>This function is typically used in combination with <a href="struct.Connection.html#method.send_on_path"><code>send_on_path()</code></a>.</p>
<p>Note that the iterator includes all the possible combination of
destination <code>SockAddr</code>s, even those whose sending is not required now.
In other words, this is another way for the application to recall from
past <a href="enum.PathEvent.html#variant.New"><code>PathEvent::New</code></a> events.</p>
<h6 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Iterate over possible destinations for the given local `SockAddr`.
</span><span class="kw">for </span>dest <span class="kw">in </span>conn.paths_iter(local) {
    <span class="kw">loop </span>{
        <span class="kw">let </span>(write, send_info) =
            <span class="kw">match </span>conn.send_on_path(<span class="kw-2">&amp;mut </span>out, <span class="prelude-val">Some</span>(local), <span class="prelude-val">Some</span>(dest)) {
                <span class="prelude-val">Ok</span>(v) =&gt; v,

                <span class="prelude-val">Err</span>(quiche::Error::Done) =&gt; {
                    <span class="comment">// Done writing for this destination.
                    </span><span class="kw">break</span>;
                },

                <span class="prelude-val">Err</span>(e) =&gt; {
                    <span class="comment">// An error occurred, handle it.
                    </span><span class="kw">break</span>;
                },
            };

        socket.send_to(<span class="kw-2">&amp;</span>out[..write], <span class="kw-2">&amp;</span>send_info.to).unwrap();
    }
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.close" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7129-7162">Source</a><h4 class="code-header">pub fn <a href="#method.close" class="fn">close</a>(&amp;mut self, app: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, err: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>, reason: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Closes the connection with the given error and reason.</p>
<p>The <code>app</code> parameter specifies whether an application close should be
sent to the peer. Otherwise a normal connection close is sent.</p>
<p>If <code>app</code> is true but the connection is not in a state that is safe to
send an application error (not established nor in early data), in
accordance with <a href="https://www.rfc-editor.org/rfc/rfc9000.html#section-10.2.3-3">RFC
9000</a>, the
error code is changed to APPLICATION_ERROR and the reason phrase is
cleared.</p>
<p>Returns <a href="enum.Error.html#variant.Done"><code>Done</code></a> if the connection had already been closed.</p>
<p>Note that the connection will not be closed immediately. An application
should continue calling the <a href="struct.Connection.html#method.recv"><code>recv()</code></a>, <a href="struct.Connection.html#method.send"><code>send()</code></a>, <a href="struct.Connection.html#method.timeout"><code>timeout()</code></a> and
<a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a> methods as normal, until the <a href="struct.Connection.html#method.is_closed"><code>is_closed()</code></a> method
returns <code>true</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trace_id" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7169-7171">Source</a><h4 class="code-header">pub fn <a href="#method.trace_id" class="fn">trace_id</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string uniquely representing the connection.</p>
<p>This can be used for logging purposes to differentiate between multiple
connections.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.application_proto" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7177-7179">Source</a><h4 class="code-header">pub fn <a href="#method.application_proto" class="fn">application_proto</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns the negotiated ALPN protocol.</p>
<p>If no protocol has been negotiated, the returned value is empty.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.server_name" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7183-7185">Source</a><h4 class="code-header">pub fn <a href="#method.server_name" class="fn">server_name</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the server name requested by the client.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_cert" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7189-7191">Source</a><h4 class="code-header">pub fn <a href="#method.peer_cert" class="fn">peer_cert</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Returns the peer’s leaf certificate (if any) as a DER-encoded buffer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_cert_chain" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7200-7202">Source</a><h4 class="code-header">pub fn <a href="#method.peer_cert_chain" class="fn">peer_cert_chain</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the peer’s certificate chain (if any) as a vector of DER-encoded
buffers.</p>
<p>The certificate at index 0 is the peer’s leaf certificate, the other
certificates (if any) are the chain certificate authorities used to
sign the leaf certificate.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.session" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7211-7213">Source</a><h4 class="code-header">pub fn <a href="#method.session" class="fn">session</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Returns the serialized cryptographic session for the connection.</p>
<p>This can be used by a client to cache a connection’s session, and resume
it later using the <a href="struct.Connection.html#method.set_session"><code>set_session()</code></a> method.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.source_id" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7223-7234">Source</a><h4 class="code-header">pub fn <a href="#method.source_id" class="fn">source_id</a>(&amp;self) -&gt; <a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns the source connection ID.</p>
<p>When there are multiple IDs, and if there is an active path, the ID used
on that path is returned. Otherwise the oldest ID is returned.</p>
<p>Note that the value returned can change throughout the connection’s
lifetime.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.source_ids" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7241-7243">Source</a><h4 class="code-header">pub fn <a href="#method.source_ids" class="fn">source_ids</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = &amp;<a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a>&lt;'_&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns all active source connection IDs.</p>
<p>An iterator is returned for all active IDs (i.e. ones that have not
been explicitly retired yet).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.destination_id" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7250-7261">Source</a><h4 class="code-header">pub fn <a href="#method.destination_id" class="fn">destination_id</a>(&amp;self) -&gt; <a class="struct" href="struct.ConnectionId.html" title="struct quiche::ConnectionId">ConnectionId</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns the destination connection ID.</p>
<p>Note that the value returned can change throughout the connection’s
lifetime.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pmtu" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7268-7274">Source</a><h4 class="code-header">pub fn <a href="#method.pmtu" class="fn">pmtu</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the PMTU for the active path if it exists.</p>
<p>This requires no additonal packets to be sent but simply checks if PMTUD
has completed and has found a valid PMTU.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.revalidate_pmtu" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7280-7286">Source</a><h4 class="code-header">pub fn <a href="#method.revalidate_pmtu" class="fn">revalidate_pmtu</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Revalidates the PMTU for the active path by sending a new probe packet
of PMTU size. If the probe is dropped PMTUD will restart and find a new
valid PMTU.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_established" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7290-7292">Source</a><h4 class="code-header">pub fn <a href="#method.is_established" class="fn">is_established</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection handshake is complete.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_resumed" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7296-7298">Source</a><h4 class="code-header">pub fn <a href="#method.is_resumed" class="fn">is_resumed</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection is resumed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_in_early_data" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7303-7305">Source</a><h4 class="code-header">pub fn <a href="#method.is_in_early_data" class="fn">is_in_early_data</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection has a pending handshake that has
progressed enough to send or receive early data.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.early_data_reason" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7314-7316">Source</a><h4 class="code-header">pub fn <a href="#method.early_data_reason" class="fn">early_data_reason</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the early data reason for the connection.</p>
<p>This status can be useful for logging and debugging. See <a href="https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#ssl_early_data_reason_t">BoringSSL</a>
documentation for a definition of the reasons.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_readable" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7320-7322">Source</a><h4 class="code-header">pub fn <a href="#method.is_readable" class="fn">is_readable</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether there is stream or DATAGRAM data available to read.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_path_validated" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7331-7340">Source</a><h4 class="code-header">pub fn <a href="#method.is_path_validated" class="fn">is_path_validated</a>(
    &amp;self,
    from: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
    to: <a class="enum" href="https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html" title="enum core::net::socket_addr::SocketAddr">SocketAddr</a>,
) -&gt; <a class="type" href="type.Result.html" title="type quiche::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns whether the network path with local address <code>from</code> and remote
address <code>peer</code> has been validated.</p>
<p>If the 4-tuple does not exist over the connection, returns an
<a href="enum.Error.html#variant.InvalidState"><code>InvalidState</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_draining" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7358-7360">Source</a><h4 class="code-header">pub fn <a href="#method.is_draining" class="fn">is_draining</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection is draining.</p>
<p>If this returns <code>true</code>, the connection object cannot yet be dropped, but
no new application data can be sent or received. An application should
continue calling the <a href="struct.Connection.html#method.recv"><code>recv()</code></a>, <a href="struct.Connection.html#method.timeout"><code>timeout()</code></a>, and <a href="struct.Connection.html#method.on_timeout"><code>on_timeout()</code></a>
methods as normal, until the <a href="struct.Connection.html#method.is_closed"><code>is_closed()</code></a> method returns <code>true</code>.</p>
<p>In contrast, once <code>is_draining()</code> returns <code>true</code>, calling <a href="struct.Connection.html#method.send"><code>send()</code></a>
is not required because no new outgoing packets will be generated.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_closed" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7366-7368">Source</a><h4 class="code-header">pub fn <a href="#method.is_closed" class="fn">is_closed</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection is closed.</p>
<p>If this returns true, the connection object can be dropped.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_timed_out" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7372-7374">Source</a><h4 class="code-header">pub fn <a href="#method.is_timed_out" class="fn">is_timed_out</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the connection was closed due to the idle timeout.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_error" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7383-7385">Source</a><h4 class="code-header">pub fn <a href="#method.peer_error" class="fn">peer_error</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.ConnectionError.html" title="struct quiche::ConnectionError">ConnectionError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the error received from the peer, if any.</p>
<p>Note that a <code>Some</code> return value does not necessarily imply
<a href="struct.Connection.html#method.is_closed"><code>is_closed()</code></a> or any other connection state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.local_error" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7398-7400">Source</a><h4 class="code-header">pub fn <a href="#method.local_error" class="fn">local_error</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.ConnectionError.html" title="struct quiche::ConnectionError">ConnectionError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the error <a href="struct.Connection.html#method.close"><code>close()</code></a> was called with, or internally
created quiche errors, if any.</p>
<p>Note that a <code>Some</code> return value does not necessarily imply
<a href="struct.Connection.html#method.is_closed"><code>is_closed()</code></a> or any other connection state.
<code>Some</code> also does not guarantee that the error has been sent to
or received by the peer.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stats" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7404-7431">Source</a><h4 class="code-header">pub fn <a href="#method.stats" class="fn">stats</a>(&amp;self) -&gt; <a class="struct" href="struct.Stats.html" title="struct quiche::Stats">Stats</a></h4></section></summary><div class="docblock"><p>Collects and returns statistics about the connection.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peer_transport_params" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7449-7455">Source</a><h4 class="code-header">pub fn <a href="#method.peer_transport_params" class="fn">peer_transport_params</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.TransportParams.html" title="struct quiche::TransportParams">TransportParams</a>&gt;</h4></section></summary><div class="docblock"><p>Returns reference to peer’s transport parameters. Returns <code>None</code> if we
have not yet processed the peer’s transport parameters.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.path_stats" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7459-7461">Source</a><h4 class="code-header">pub fn <a href="#method.path_stats" class="fn">path_stats</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="struct" href="struct.PathStats.html" title="struct quiche::PathStats">PathStats</a>&gt; + '_</h4></section></summary><div class="docblock"><p>Collects and returns statistics about each known path for the
connection.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_server" class="method"><a class="src rightside" href="../src/quiche/lib.rs.html#7464-7466">Source</a><h4 class="code-header">pub fn <a href="#method.is_server" class="fn">is_server</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns whether or not this is a server-side connection.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsMut%3CSslRef%3E-for-Connection%3CF%3E" class="impl"><a class="src rightside" href="../src/quiche/lib.rs.html#8867-8871">Source</a><a href="#impl-AsMut%3CSslRef%3E-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F: <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;SslRef&gt; for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>boringssl-boring-crate</code></strong> only.</div></span></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl"><a class="src rightside" href="../src/quiche/lib.rs.html#8868-8870">Source</a><a href="#method.as_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.AsMut.html#tymethod.as_mut" class="fn">as_mut</a>(&amp;mut self) -&gt; &amp;mut SslRef</h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Connection%3CF%3E" class="impl"><a href="#impl-Freeze-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3></section><section id="impl-RefUnwindSafe-for-Connection%3CF%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F = DefaultBufFactory&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3></section><section id="impl-Send-for-Connection%3CF%3E" class="impl"><a href="#impl-Send-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;<div class="where">where
    &lt;F as <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>&gt;::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-Connection%3CF%3E" class="impl"><a href="#impl-Sync-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;<div class="where">where
    &lt;F as <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>&gt;::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-Connection%3CF%3E" class="impl"><a href="#impl-Unpin-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;<div class="where">where
    &lt;F as <a class="trait" href="trait.BufFactory.html" title="trait quiche::BufFactory">BufFactory</a>&gt;::<a class="associatedtype" href="trait.BufFactory.html#associatedtype.Buf" title="type quiche::BufFactory::Buf">Buf</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnsafeUnpin-for-Connection%3CF%3E" class="impl"><a href="#impl-UnsafeUnpin-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.UnsafeUnpin.html" title="trait core::marker::UnsafeUnpin">UnsafeUnpin</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3></section><section id="impl-UnwindSafe-for-Connection%3CF%3E" class="impl"><a href="#impl-UnwindSafe-for-Connection%3CF%3E" class="anchor">§</a><h3 class="code-header">impl&lt;F = DefaultBufFactory&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Connection.html" title="struct quiche::Connection">Connection</a>&lt;F&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#141">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#142">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>","SocketAddrIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.SocketAddrIter.html\" title=\"struct quiche::SocketAddrIter\">SocketAddrIter</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.SocketAddrIter.html\" title=\"struct quiche::SocketAddrIter\">SocketAddrIter</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/net/socket_addr/enum.SocketAddr.html\" title=\"enum core::net::socket_addr::SocketAddr\">SocketAddr</a>;</div>","StreamIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.StreamIter.html\" title=\"struct quiche::StreamIter\">StreamIter</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.StreamIter.html\" title=\"struct quiche::StreamIter\">StreamIter</a></div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>;</div>"}</script></section></div></main></body></html>